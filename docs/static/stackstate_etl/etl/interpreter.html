<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stackstate_etl.etl.interpreter API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stackstate_etl.etl.interpreter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import importlib
import math
from logging import Logger
from typing import Any, Dict, List, Optional, Union

import attr
import pandas
import pydash
import pytz
import requests
from asteval import Interpreter
from jsonpath_ng.exceptions import JsonPathLexerError, JsonPathParserError
from six import string_types

from stackstate_etl.model.etl import (ComponentTemplate, ComponentTemplateSpec,
                                      DataSource, EventTemplate,
                                      EventTemplateSpec, HealthTemplate,
                                      HealthTemplateSpec, MetricTemplate,
                                      MetricTemplateSpec, ProcessorSpec, Query)
from stackstate_etl.model.factory import TopologyFactory
from stackstate_etl.model.instance import InstanceInfo
from stackstate_etl.model.stackstate import (EVENT_CATEGORY_CHOICES,
                                             HEALTH_STATE_CHOICES,
                                             METRIC_TYPE_CHOICES, Component,
                                             Event, HealthCheckState, Metric,
                                             SourceLink)


@attr.s(kw_only=True)
class TopologyContext:
    factory: TopologyFactory = attr.ib()
    item: Dict[str, Any] = attr.ib(default=None)
    datasources: Dict[str, Any] = attr.ib(default={})
    component: Component = attr.ib(default=None)
    event: Event = attr.ib(default=None)
    metric: Metric = attr.ib(default=None)
    health: HealthCheckState = attr.ib(default=None)
    session: Dict[str, Any] = attr.ib(default={})
    global_session: Dict[str, Any] = attr.ib(default={})

    def jpath(self, path) -&gt; Any:
        return self.factory.jpath(path, self.item)


class BaseInterpreter:
    def __init__(self, ctx: TopologyContext):
        self.ctx = ctx
        self.aeval = Interpreter()
        self.source_name = &#34;default&#34;
        self._init_static_symtable()

    def _init_static_symtable(self):
        symtable = self.aeval.symtable
        ctx = self.ctx
        symtable[&#34;factory&#34;] = ctx.factory
        symtable[&#34;jpath&#34;] = ctx.jpath
        symtable[&#34;session&#34;] = ctx.session
        symtable[&#34;global_session&#34;] = ctx.global_session
        symtable[&#34;uid&#34;] = ctx.factory.get_uid
        symtable[&#34;py_&#34;] = pydash
        symtable[&#34;datetime&#34;] = datetime
        symtable[&#34;pytz&#34;] = pytz
        symtable[&#34;math&#34;] = math
        symtable[&#34;requests&#34;] = requests
        symtable[&#34;pandas&#34;] = pandas
        symtable[&#34;log&#34;] = ctx.factory.log

    def _run_code(self, code: str, property_name) -&gt; Any:
        if code is None:
            return
        code = code.strip()
        if code.startswith(&#34;|&#34;):
            code = code[1:]
        self._update_asteval_symtable()
        value = self._eval_expression(code, property_name)
        return value

    def _eval_expression(self, expression: str, eval_property: str, fail_on_error: bool = True) -&gt; Any:
        existing_errs = len(self.aeval.error)
        result = self.aeval.eval(expression)
        if len(self.aeval.error) &gt; existing_errs and fail_on_error:
            error_messages = []
            for err in self.aeval.error:
                lineno = 0 if not err.node else err.node.lineno
                error_messages.append((err.msg, lineno, err.get_error()))
            error_lines = [
                (
                    f&#34;Failed to evaluate property &#39;{eval_property}&#39; on &#34;
                    f&#34;`{self._get_eval_expression_failed_source()}`. &#34;
                ),
                &#34;-&#34; * 40,
                expression,
                &#34;-&#34; * 40,
            ]
            for msg, line_num, error_message in error_messages:
                error_lines.append(f&#34;Error: {error_message[0]} - {msg}&#34;)
                error_lines.append(f&#34;Line Number: {line_num}&#34;)
                error_lines.append(&#34;-&#34; * 40)
                inner_lines = error_message[1].split(&#34;\n&#34;)
                error_lines.extend(inner_lines)
                error_lines.append(&#34;-&#34; * 40)
            raise Exception(&#34;\n&#34;.join(error_lines))
        return result

    def _get_eval_expression_failed_source(self) -&gt; str:
        return self.source_name

    def _update_asteval_symtable(self) -&gt; Dict[str, Any]:
        symtable = self.aeval.symtable
        ctx = self.ctx
        symtable[&#34;item&#34;] = ctx.item
        symtable[&#34;component&#34;] = ctx.component
        symtable[&#34;metric&#34;] = ctx.metric
        symtable[&#34;event&#34;] = ctx.event
        symtable[&#34;health&#34;] = ctx.health
        for name, ds in ctx.datasources.items():
            symtable[name] = ds
        return symtable


class DataSourceInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, datasource: DataSource, instance_info: InstanceInfo, log: Logger) -&gt; object:
        self.source_name = f&#34;datasource &#39;{datasource.name}&#39;&#34;
        ds_class = None
        if datasource.module and datasource.cls:
            try:
                module = importlib.import_module(datasource.module)
            except Exception as e:
                raise Exception(
                    f&#34;Failed to load module &#39;{datasource.module}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                    f&#34; Message: {str(e)} &#34;
                )
            try:
                ds_class = getattr(module, datasource.cls)
            except Exception as e:
                raise Exception(
                    f&#34;Failed to load class &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                    f&#34; Message: {str(e)} &#34;
                )

        symtable = self._update_asteval_symtable()
        symtable[&#34;conf&#34;] = instance_info
        symtable[datasource.cls] = ds_class

        try:
            ds_instance = self._run_code(datasource.init, &#34;init&#34;)
            if ds_instance is None:
                raise Exception(f&#34;Value returns from init for datasource  &#39;{datasource.name} cannot be None.&#34;)
        except Exception as e:
            raise Exception(
                f&#34;Failed to create class instance &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                f&#34; Message: {str(e)} &#34;
            )

        self.ctx.datasources[datasource.name] = ds_instance
        return ds_instance


class QueryInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, query: Query) -&gt; List[Dict[str, Any]]:
        self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
        self._update_asteval_symtable()
        items = self._run_code(query.query, &#34;query&#34;)
        if items is None:
            items = []
        if not isinstance(items, list):
            items = [items]
        return items


class QueryProcessorInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, query: Query):
        self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
        self._update_asteval_symtable()
        self._run_code(query.processor, &#34;processor&#34;)


class ProcessorInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, processor: ProcessorSpec):
        self.source_name = f&#34;processor &#39;{processor.name}&#39;&#34;
        self._update_asteval_symtable()
        self._run_code(processor.code, &#34;code&#34;)


class BaseTemplateInterpreter(BaseInterpreter):
    def __init__(
        self,
        ctx: TopologyContext,
        template: Union[ComponentTemplate, EventTemplate, MetricTemplate, HealthTemplate],
        domain: str,
        layer: str,
        environment: str,
    ):
        BaseInterpreter.__init__(self, ctx)
        self.environment = environment
        self.layer = layer
        self.domain = domain
        self.template_name = template.name
        self.template = template
        self.source_name = self.template_name

    def active(self, item: Any) -&gt; bool:
        template = self.template
        self.ctx.item = item
        if template.selector is None:
            return True
        return self._get_value(template.selector, &#34;selector&#34;)

    def _merge_list_property(self, value: Union[Optional[str], List[str]], name: str) -&gt; List[str]:
        if value is None:
            return []
        elif isinstance(value, string_types):
            return self._get_list_property(value, name)
        else:
            return [self._get_string_property(v, name) for v in value]

    def _get_string_property(self, expression: str, name: str, default: str = None) -&gt; str:
        value = self._get_value(expression, name, default=default)
        return self._assert_string(value, name)

    def _get_float_property(self, expression: str, name: str, default: float = 0.0) -&gt; float:
        value = self._get_value(expression, name, default=default)
        return self._assert_float(value, name)

    def _get_list_property(self, expression: Union[str, list], name: str, default=None) -&gt; List[Any]:
        if default is None:
            default = []
        if isinstance(expression, string_types):
            values = self._get_value(expression, name, default=default, force_eval=True)
        else:
            values = expression
        values = self._assert_list(values, name)
        return [self._get_string_property(v, name) for v in values]

    def _get_dict_property(self, expression: Union[str, Dict[str, Any]], name: str, default=None) -&gt; Dict[str, Any]:
        if default is None:
            default = {}
        if isinstance(expression, string_types):
            values = self._get_value(expression, name, default=default, force_eval=True)
        else:
            values = expression
        values = self._assert_dict(values, name)
        result: Dict[str, Any] = {}
        for k, v in values.items():
            result[k] = self._get_value(v, f&#34;{name}:{k}&#34;)
        return result

    def _get_value(self, expression: str, name: str, default: Any = None, force_eval=False) -&gt; Any:
        if expression is None:
            return default
        if expression.startswith(&#34;$.&#34;):
            try:
                return self.ctx.factory.jpath(expression, self.ctx.item, default)
            except (JsonPathParserError, JsonPathLexerError) as e:
                raise Exception(
                    f&#34;Failed to evaluate property &#39;{name}&#39; for &#39;{self.source_name}&#39; on template `{self.template_name}`.&#34;
                    f&#34; Expression |\n {expression} \n |.\n Errors:\n {str(e)}&#34;
                )
        elif expression.startswith(&#34;|&#34;) or force_eval:
            result = self._run_code(expression, name)
            if result is None:
                return default
            return result
        else:
            return expression

    def _assert_string(self, value: Any, name: str) -&gt; str:
        if value is not None:
            if not isinstance(value, string_types):
                self._raise_assert_error(value, name, &#34;str&#34;)
        return value

    def _assert_float(self, value: Any, name: str) -&gt; float:
        if value is not None:
            if isinstance(value, string_types) or isinstance(value, int):
                try:
                    return float(value)
                except Exception:
                    self._raise_assert_error(value, name, &#34;float&#34;)
            elif not isinstance(value, float):
                self._raise_assert_error(value, name, &#34;float&#34;)
        return value

    def _assert_list(self, value: Any, name: str) -&gt; List[Any]:
        if value is not None:
            if not isinstance(value, list):
                self._raise_assert_error(value, name, &#34;list&#34;)
        return value

    def _assert_dict(self, value: Any, name: str) -&gt; Dict[str, Any]:
        if value is not None:
            if not isinstance(value, dict):
                self._raise_assert_error(value, name, &#34;dict&#34;)
        return value

    def _raise_assert_error(self, value: Any, name: str, expected: str):
        raise AssertionError(
            f&#34;Expected {expected} type for &#39;{name}&#39;, but was {type(value)} &#34;
            f&#34;for &#39;{self.source_name}&#39; on `{self.template_name}`&#34;
        )

    def _get_eval_expression_failed_source(self) -&gt; str:
        return f&#34;template  `{self.template_name}` instance &#39;{self.source_name}&#39;&#34;


class ComponentTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: ComponentTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Component:
        template = self.template
        self.ctx.item = item
        self.ctx.component = Component()
        self._update_asteval_symtable()
        if template.spec and template.code:
            raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
        if template.spec:
            return self._interpret_spec(template.spec)
        elif template.code:
            return self._interpret_code(template.code)
        else:
            raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)

    def _interpret_spec(self, spec: ComponentTemplateSpec) -&gt; Component:
        component: Component = self.ctx.component
        component.set_type(self._get_string_property(spec.component_type, &#34;type&#34;))
        component.set_name(self._get_string_property(spec.name, &#34;name&#34;))
        if component.get_name() is None:
            raise Exception(
                f&#34;Component name is required for &#39;{component.get_type()}&#39; on template&#34; f&#34; `{self.template_name}.&#34;
            )
        self.source_name = component.get_name()
        component.properties.layer = self._get_string_property(spec.layer, &#34;layer&#34;, self.layer)
        component.properties.domain = self._get_string_property(spec.domain, &#34;domain&#34;, self.domain)
        component.properties.environment = self._get_string_property(spec.environment, &#34;environment&#34;, self.environment)
        component.properties.labels.extend(self._merge_list_property(spec.labels, &#34;labels&#34;))
        component.properties.custom_properties.update(
            self._get_dict_property(spec.custom_properties, &#34;custom_properties&#34;)
        )
        component.uid = self._get_string_property(spec.uid, &#34;uid&#34;, None)
        if component.uid is None:
            raise Exception(f&#34;Component uid is required on template&#34; f&#34; `{self.template_name}.&#34;)
        self._run_code(spec.processor, &#34;processor&#34;)
        component.mergeable = spec.mergeable

        component.properties.identifiers.extend(self._merge_list_property(spec.identifiers, &#34;identifiers&#34;))
        component.properties.identifiers.append(component.uid)
        self.ctx.factory.add_component_relations(component, self._get_list_property(spec.relations, &#34;relations&#34;, []))
        self.ctx.factory.add_component(component)
        return component

    def _interpret_code(self, code: str) -&gt; Component:
        component = self.ctx.component
        self._run_code(code, &#34;code&#34;)
        if component.get_name() is None:
            raise Exception(f&#34;Component name is required for on template `{self.template_name}.&#34;)
        if component.properties.layer == &#34;Unknown&#34;:
            component.properties.layer = self.layer
        if component.properties.domain == &#34;Unknown&#34;:
            component.properties.domain = self.domain
        if component.uid is None:
            raise Exception(f&#34;Component uid is required on template&#34; f&#34; `{self.template_name}.&#34;)

        component.properties.identifiers.append(component.uid)
        self.ctx.factory.add_component(component)

        return component


class MetricTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: MetricTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Optional[Metric]:
        template: MetricTemplate = self.template
        self.ctx.item = item

        if template.spec and template.code:
            raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
        if template.spec:
            return self._interpret_spec(template.spec, template)
        elif template.code:
            return self._interpret_code(template.code)
        else:
            raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)

    def _interpret_spec(self, spec: MetricTemplateSpec, template: MetricTemplate):
        self.ctx.metric = metric = Metric()
        self._update_asteval_symtable()
        metric.name = self._get_string_property(spec.name, &#34;name&#34;, None)
        if metric.name is None:
            raise Exception(f&#34;Template {template.name} metric name is required.&#34;)
        metric.target_uid = self._get_string_property(spec.target_uid, &#34;target_uid&#34;, None)
        metric_type = self._get_string_property(spec.metric_type, &#34;metric_type&#34;, &#34;gauge&#34;)
        if metric_type not in METRIC_TYPE_CHOICES:
            raise Exception(
                f&#34;Template {template.name} metric type &#39;{metric_type}&#39; not allowed. &#34;
                f&#34;Valid values {METRIC_TYPE_CHOICES}.&#34;
            )
        metric.metric_type = metric_type
        metric.value = self._get_float_property(spec.value, &#34;value&#34;)
        metric.tags = self._get_list_property(spec.tags, &#34;tags&#34;, [])
        self.ctx.factory.add_metric(metric)

    def _interpret_code(self, code: str):
        self._update_asteval_symtable()
        self._run_code(code, &#34;code&#34;)


class EventTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: EventTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Event:
        template: EventTemplate = self.template
        self.ctx.item = item
        self.ctx.event = event = Event()
        self._update_asteval_symtable()
        spec: EventTemplateSpec = template.spec

        event.event_type = self._get_string_property(spec.event_type, &#34;event_type&#34;, None)
        if event.event_type is None:
            raise Exception(f&#34;Template {template.name} event type is required.&#34;)

        category = self._get_string_property(spec.category, &#34;category&#34;, &#34;&#34;)
        if category not in EVENT_CATEGORY_CHOICES:
            raise Exception(
                f&#34;Template {template.name} event category &#39;{category}&#39; not allowed. &#34;
                f&#34;Valid values {EVENT_CATEGORY_CHOICES}.&#34;
            )

        event.context.category = category
        event.context.element_identifiers = self._get_list_property(spec.element_identifiers, &#34;element_identifiers&#34;, [])
        event.context.data = self._get_dict_property(spec.data, &#34;data&#34;)

        for source_link in spec.source_links:
            sl = SourceLink()
            sl.title = self._get_string_property(source_link.title, &#34;sourcelink.title&#34;, None)
            sl.url = self._get_string_property(source_link.url, &#34;sourcelink.url&#34;, None)
            event.context.source_links.append(sl)
        event.tags = self._get_list_property(spec.tags, &#34;tags&#34;, [])
        source = self._get_string_property(spec.source, &#34;source&#34;, &#34;ETL&#34;)
        event.context.source = source
        event.source = source
        event.msg_title = self._get_string_property(spec.msg_title, &#34;msg_title&#34;, None)
        if event.msg_title is None:
            raise Exception(f&#34;Template {template.name} event msg title is required.&#34;)
        event.msg_text = self._get_string_property(spec.msg_text, &#34;msg_text&#34;)
        self.ctx.factory.add_event(event)
        return event


class HeathTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: HealthTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; HealthCheckState:
        template: HealthTemplate = self.template
        self.ctx.item = item
        self.ctx.health = health = HealthCheckState()
        self._update_asteval_symtable()
        spec: HealthTemplateSpec = template.spec

        health.check_id = self._get_string_property(spec.check_id, &#34;check_id&#34;, None)
        if health.check_id is None:
            raise Exception(f&#34;Template {template.name} health check id required.&#34;)

        health.check_name = self._get_string_property(spec.check_name, &#34;check_name&#34;, None)
        if health.check_name is None:
            raise Exception(f&#34;Template {template.name} health check name required.&#34;)

        health.topo_identifier = self._get_string_property(spec.topo_identifier, &#34;topo_identifier&#34;, None)
        if health.topo_identifier is None:
            raise Exception(f&#34;Template {template.name} health topo_identifier required.&#34;)

        health.message = self._get_string_property(spec.message, &#34;message&#34;, &#34;&#34;)

        health_status = self._get_string_property(spec.health, &#34;health&#34;, &#34;&#34;)
        if health_status not in HEALTH_STATE_CHOICES:
            raise Exception(
                f&#34;Template {template.name} health &#39;{health_status}&#39; not allowed. &#34;
                f&#34;Valid values {HEALTH_STATE_CHOICES}.&#34;
            )

        health.health = health_status
        self.ctx.factory.add_health(health)
        return health</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stackstate_etl.etl.interpreter.BaseInterpreter"><code class="flex name class">
<span>class <span class="ident">BaseInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseInterpreter:
    def __init__(self, ctx: TopologyContext):
        self.ctx = ctx
        self.aeval = Interpreter()
        self.source_name = &#34;default&#34;
        self._init_static_symtable()

    def _init_static_symtable(self):
        symtable = self.aeval.symtable
        ctx = self.ctx
        symtable[&#34;factory&#34;] = ctx.factory
        symtable[&#34;jpath&#34;] = ctx.jpath
        symtable[&#34;session&#34;] = ctx.session
        symtable[&#34;global_session&#34;] = ctx.global_session
        symtable[&#34;uid&#34;] = ctx.factory.get_uid
        symtable[&#34;py_&#34;] = pydash
        symtable[&#34;datetime&#34;] = datetime
        symtable[&#34;pytz&#34;] = pytz
        symtable[&#34;math&#34;] = math
        symtable[&#34;requests&#34;] = requests
        symtable[&#34;pandas&#34;] = pandas
        symtable[&#34;log&#34;] = ctx.factory.log

    def _run_code(self, code: str, property_name) -&gt; Any:
        if code is None:
            return
        code = code.strip()
        if code.startswith(&#34;|&#34;):
            code = code[1:]
        self._update_asteval_symtable()
        value = self._eval_expression(code, property_name)
        return value

    def _eval_expression(self, expression: str, eval_property: str, fail_on_error: bool = True) -&gt; Any:
        existing_errs = len(self.aeval.error)
        result = self.aeval.eval(expression)
        if len(self.aeval.error) &gt; existing_errs and fail_on_error:
            error_messages = []
            for err in self.aeval.error:
                lineno = 0 if not err.node else err.node.lineno
                error_messages.append((err.msg, lineno, err.get_error()))
            error_lines = [
                (
                    f&#34;Failed to evaluate property &#39;{eval_property}&#39; on &#34;
                    f&#34;`{self._get_eval_expression_failed_source()}`. &#34;
                ),
                &#34;-&#34; * 40,
                expression,
                &#34;-&#34; * 40,
            ]
            for msg, line_num, error_message in error_messages:
                error_lines.append(f&#34;Error: {error_message[0]} - {msg}&#34;)
                error_lines.append(f&#34;Line Number: {line_num}&#34;)
                error_lines.append(&#34;-&#34; * 40)
                inner_lines = error_message[1].split(&#34;\n&#34;)
                error_lines.extend(inner_lines)
                error_lines.append(&#34;-&#34; * 40)
            raise Exception(&#34;\n&#34;.join(error_lines))
        return result

    def _get_eval_expression_failed_source(self) -&gt; str:
        return self.source_name

    def _update_asteval_symtable(self) -&gt; Dict[str, Any]:
        symtable = self.aeval.symtable
        ctx = self.ctx
        symtable[&#34;item&#34;] = ctx.item
        symtable[&#34;component&#34;] = ctx.component
        symtable[&#34;metric&#34;] = ctx.metric
        symtable[&#34;event&#34;] = ctx.event
        symtable[&#34;health&#34;] = ctx.health
        for name, ds in ctx.datasources.items():
            symtable[name] = ds
        return symtable</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.DataSourceInterpreter" href="#stackstate_etl.etl.interpreter.DataSourceInterpreter">DataSourceInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.ProcessorInterpreter" href="#stackstate_etl.etl.interpreter.ProcessorInterpreter">ProcessorInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.QueryInterpreter" href="#stackstate_etl.etl.interpreter.QueryInterpreter">QueryInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.QueryProcessorInterpreter" href="#stackstate_etl.etl.interpreter.QueryProcessorInterpreter">QueryProcessorInterpreter</a></li>
</ul>
</dd>
<dt id="stackstate_etl.etl.interpreter.BaseTemplateInterpreter"><code class="flex name class">
<span>class <span class="ident">BaseTemplateInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>, template: Union[<a title="stackstate_etl.model.etl.ComponentTemplate" href="../model/etl.html#stackstate_etl.model.etl.ComponentTemplate">ComponentTemplate</a>, <a title="stackstate_etl.model.etl.EventTemplate" href="../model/etl.html#stackstate_etl.model.etl.EventTemplate">EventTemplate</a>, <a title="stackstate_etl.model.etl.MetricTemplate" href="../model/etl.html#stackstate_etl.model.etl.MetricTemplate">MetricTemplate</a>, <a title="stackstate_etl.model.etl.HealthTemplate" href="../model/etl.html#stackstate_etl.model.etl.HealthTemplate">HealthTemplate</a>], domain: str, layer: str, environment: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseTemplateInterpreter(BaseInterpreter):
    def __init__(
        self,
        ctx: TopologyContext,
        template: Union[ComponentTemplate, EventTemplate, MetricTemplate, HealthTemplate],
        domain: str,
        layer: str,
        environment: str,
    ):
        BaseInterpreter.__init__(self, ctx)
        self.environment = environment
        self.layer = layer
        self.domain = domain
        self.template_name = template.name
        self.template = template
        self.source_name = self.template_name

    def active(self, item: Any) -&gt; bool:
        template = self.template
        self.ctx.item = item
        if template.selector is None:
            return True
        return self._get_value(template.selector, &#34;selector&#34;)

    def _merge_list_property(self, value: Union[Optional[str], List[str]], name: str) -&gt; List[str]:
        if value is None:
            return []
        elif isinstance(value, string_types):
            return self._get_list_property(value, name)
        else:
            return [self._get_string_property(v, name) for v in value]

    def _get_string_property(self, expression: str, name: str, default: str = None) -&gt; str:
        value = self._get_value(expression, name, default=default)
        return self._assert_string(value, name)

    def _get_float_property(self, expression: str, name: str, default: float = 0.0) -&gt; float:
        value = self._get_value(expression, name, default=default)
        return self._assert_float(value, name)

    def _get_list_property(self, expression: Union[str, list], name: str, default=None) -&gt; List[Any]:
        if default is None:
            default = []
        if isinstance(expression, string_types):
            values = self._get_value(expression, name, default=default, force_eval=True)
        else:
            values = expression
        values = self._assert_list(values, name)
        return [self._get_string_property(v, name) for v in values]

    def _get_dict_property(self, expression: Union[str, Dict[str, Any]], name: str, default=None) -&gt; Dict[str, Any]:
        if default is None:
            default = {}
        if isinstance(expression, string_types):
            values = self._get_value(expression, name, default=default, force_eval=True)
        else:
            values = expression
        values = self._assert_dict(values, name)
        result: Dict[str, Any] = {}
        for k, v in values.items():
            result[k] = self._get_value(v, f&#34;{name}:{k}&#34;)
        return result

    def _get_value(self, expression: str, name: str, default: Any = None, force_eval=False) -&gt; Any:
        if expression is None:
            return default
        if expression.startswith(&#34;$.&#34;):
            try:
                return self.ctx.factory.jpath(expression, self.ctx.item, default)
            except (JsonPathParserError, JsonPathLexerError) as e:
                raise Exception(
                    f&#34;Failed to evaluate property &#39;{name}&#39; for &#39;{self.source_name}&#39; on template `{self.template_name}`.&#34;
                    f&#34; Expression |\n {expression} \n |.\n Errors:\n {str(e)}&#34;
                )
        elif expression.startswith(&#34;|&#34;) or force_eval:
            result = self._run_code(expression, name)
            if result is None:
                return default
            return result
        else:
            return expression

    def _assert_string(self, value: Any, name: str) -&gt; str:
        if value is not None:
            if not isinstance(value, string_types):
                self._raise_assert_error(value, name, &#34;str&#34;)
        return value

    def _assert_float(self, value: Any, name: str) -&gt; float:
        if value is not None:
            if isinstance(value, string_types) or isinstance(value, int):
                try:
                    return float(value)
                except Exception:
                    self._raise_assert_error(value, name, &#34;float&#34;)
            elif not isinstance(value, float):
                self._raise_assert_error(value, name, &#34;float&#34;)
        return value

    def _assert_list(self, value: Any, name: str) -&gt; List[Any]:
        if value is not None:
            if not isinstance(value, list):
                self._raise_assert_error(value, name, &#34;list&#34;)
        return value

    def _assert_dict(self, value: Any, name: str) -&gt; Dict[str, Any]:
        if value is not None:
            if not isinstance(value, dict):
                self._raise_assert_error(value, name, &#34;dict&#34;)
        return value

    def _raise_assert_error(self, value: Any, name: str, expected: str):
        raise AssertionError(
            f&#34;Expected {expected} type for &#39;{name}&#39;, but was {type(value)} &#34;
            f&#34;for &#39;{self.source_name}&#39; on `{self.template_name}`&#34;
        )

    def _get_eval_expression_failed_source(self) -&gt; str:
        return f&#34;template  `{self.template_name}` instance &#39;{self.source_name}&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.ComponentTemplateInterpreter" href="#stackstate_etl.etl.interpreter.ComponentTemplateInterpreter">ComponentTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.EventTemplateInterpreter" href="#stackstate_etl.etl.interpreter.EventTemplateInterpreter">EventTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.HeathTemplateInterpreter" href="#stackstate_etl.etl.interpreter.HeathTemplateInterpreter">HeathTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.MetricTemplateInterpreter" href="#stackstate_etl.etl.interpreter.MetricTemplateInterpreter">MetricTemplateInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.BaseTemplateInterpreter.active"><code class="name flex">
<span>def <span class="ident">active</span></span>(<span>self, item: Any) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def active(self, item: Any) -&gt; bool:
    template = self.template
    self.ctx.item = item
    if template.selector is None:
        return True
    return self._get_value(template.selector, &#34;selector&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.ComponentTemplateInterpreter"><code class="flex name class">
<span>class <span class="ident">ComponentTemplateInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>, template: <a title="stackstate_etl.model.etl.ComponentTemplate" href="../model/etl.html#stackstate_etl.model.etl.ComponentTemplate">ComponentTemplate</a>, domain: str, layer: str, environment: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComponentTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: ComponentTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Component:
        template = self.template
        self.ctx.item = item
        self.ctx.component = Component()
        self._update_asteval_symtable()
        if template.spec and template.code:
            raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
        if template.spec:
            return self._interpret_spec(template.spec)
        elif template.code:
            return self._interpret_code(template.code)
        else:
            raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)

    def _interpret_spec(self, spec: ComponentTemplateSpec) -&gt; Component:
        component: Component = self.ctx.component
        component.set_type(self._get_string_property(spec.component_type, &#34;type&#34;))
        component.set_name(self._get_string_property(spec.name, &#34;name&#34;))
        if component.get_name() is None:
            raise Exception(
                f&#34;Component name is required for &#39;{component.get_type()}&#39; on template&#34; f&#34; `{self.template_name}.&#34;
            )
        self.source_name = component.get_name()
        component.properties.layer = self._get_string_property(spec.layer, &#34;layer&#34;, self.layer)
        component.properties.domain = self._get_string_property(spec.domain, &#34;domain&#34;, self.domain)
        component.properties.environment = self._get_string_property(spec.environment, &#34;environment&#34;, self.environment)
        component.properties.labels.extend(self._merge_list_property(spec.labels, &#34;labels&#34;))
        component.properties.custom_properties.update(
            self._get_dict_property(spec.custom_properties, &#34;custom_properties&#34;)
        )
        component.uid = self._get_string_property(spec.uid, &#34;uid&#34;, None)
        if component.uid is None:
            raise Exception(f&#34;Component uid is required on template&#34; f&#34; `{self.template_name}.&#34;)
        self._run_code(spec.processor, &#34;processor&#34;)
        component.mergeable = spec.mergeable

        component.properties.identifiers.extend(self._merge_list_property(spec.identifiers, &#34;identifiers&#34;))
        component.properties.identifiers.append(component.uid)
        self.ctx.factory.add_component_relations(component, self._get_list_property(spec.relations, &#34;relations&#34;, []))
        self.ctx.factory.add_component(component)
        return component

    def _interpret_code(self, code: str) -&gt; Component:
        component = self.ctx.component
        self._run_code(code, &#34;code&#34;)
        if component.get_name() is None:
            raise Exception(f&#34;Component name is required for on template `{self.template_name}.&#34;)
        if component.properties.layer == &#34;Unknown&#34;:
            component.properties.layer = self.layer
        if component.properties.domain == &#34;Unknown&#34;:
            component.properties.domain = self.domain
        if component.uid is None:
            raise Exception(f&#34;Component uid is required on template&#34; f&#34; `{self.template_name}.&#34;)

        component.properties.identifiers.append(component.uid)
        self.ctx.factory.add_component(component)

        return component</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.ComponentTemplateInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, item: Dict[str, Any]) ‑> <a title="stackstate_etl.model.stackstate.Component" href="../model/stackstate.html#stackstate_etl.model.stackstate.Component">Component</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, item: Dict[str, Any]) -&gt; Component:
    template = self.template
    self.ctx.item = item
    self.ctx.component = Component()
    self._update_asteval_symtable()
    if template.spec and template.code:
        raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
    if template.spec:
        return self._interpret_spec(template.spec)
    elif template.code:
        return self._interpret_code(template.code)
    else:
        raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.DataSourceInterpreter"><code class="flex name class">
<span>class <span class="ident">DataSourceInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataSourceInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, datasource: DataSource, instance_info: InstanceInfo, log: Logger) -&gt; object:
        self.source_name = f&#34;datasource &#39;{datasource.name}&#39;&#34;
        ds_class = None
        if datasource.module and datasource.cls:
            try:
                module = importlib.import_module(datasource.module)
            except Exception as e:
                raise Exception(
                    f&#34;Failed to load module &#39;{datasource.module}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                    f&#34; Message: {str(e)} &#34;
                )
            try:
                ds_class = getattr(module, datasource.cls)
            except Exception as e:
                raise Exception(
                    f&#34;Failed to load class &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                    f&#34; Message: {str(e)} &#34;
                )

        symtable = self._update_asteval_symtable()
        symtable[&#34;conf&#34;] = instance_info
        symtable[datasource.cls] = ds_class

        try:
            ds_instance = self._run_code(datasource.init, &#34;init&#34;)
            if ds_instance is None:
                raise Exception(f&#34;Value returns from init for datasource  &#39;{datasource.name} cannot be None.&#34;)
        except Exception as e:
            raise Exception(
                f&#34;Failed to create class instance &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                f&#34; Message: {str(e)} &#34;
            )

        self.ctx.datasources[datasource.name] = ds_instance
        return ds_instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.DataSourceInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, datasource: <a title="stackstate_etl.model.etl.DataSource" href="../model/etl.html#stackstate_etl.model.etl.DataSource">DataSource</a>, instance_info: <a title="stackstate_etl.model.instance.InstanceInfo" href="../model/instance.html#stackstate_etl.model.instance.InstanceInfo">InstanceInfo</a>, log: logging.Logger) ‑> object</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, datasource: DataSource, instance_info: InstanceInfo, log: Logger) -&gt; object:
    self.source_name = f&#34;datasource &#39;{datasource.name}&#39;&#34;
    ds_class = None
    if datasource.module and datasource.cls:
        try:
            module = importlib.import_module(datasource.module)
        except Exception as e:
            raise Exception(
                f&#34;Failed to load module &#39;{datasource.module}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                f&#34; Message: {str(e)} &#34;
            )
        try:
            ds_class = getattr(module, datasource.cls)
        except Exception as e:
            raise Exception(
                f&#34;Failed to load class &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
                f&#34; Message: {str(e)} &#34;
            )

    symtable = self._update_asteval_symtable()
    symtable[&#34;conf&#34;] = instance_info
    symtable[datasource.cls] = ds_class

    try:
        ds_instance = self._run_code(datasource.init, &#34;init&#34;)
        if ds_instance is None:
            raise Exception(f&#34;Value returns from init for datasource  &#39;{datasource.name} cannot be None.&#34;)
    except Exception as e:
        raise Exception(
            f&#34;Failed to create class instance &#39;{datasource.cls}&#39; for datasource &#39;{datasource.name}&#39;.&#34;
            f&#34; Message: {str(e)} &#34;
        )

    self.ctx.datasources[datasource.name] = ds_instance
    return ds_instance</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.EventTemplateInterpreter"><code class="flex name class">
<span>class <span class="ident">EventTemplateInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>, template: <a title="stackstate_etl.model.etl.EventTemplate" href="../model/etl.html#stackstate_etl.model.etl.EventTemplate">EventTemplate</a>, domain: str, layer: str, environment: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: EventTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Event:
        template: EventTemplate = self.template
        self.ctx.item = item
        self.ctx.event = event = Event()
        self._update_asteval_symtable()
        spec: EventTemplateSpec = template.spec

        event.event_type = self._get_string_property(spec.event_type, &#34;event_type&#34;, None)
        if event.event_type is None:
            raise Exception(f&#34;Template {template.name} event type is required.&#34;)

        category = self._get_string_property(spec.category, &#34;category&#34;, &#34;&#34;)
        if category not in EVENT_CATEGORY_CHOICES:
            raise Exception(
                f&#34;Template {template.name} event category &#39;{category}&#39; not allowed. &#34;
                f&#34;Valid values {EVENT_CATEGORY_CHOICES}.&#34;
            )

        event.context.category = category
        event.context.element_identifiers = self._get_list_property(spec.element_identifiers, &#34;element_identifiers&#34;, [])
        event.context.data = self._get_dict_property(spec.data, &#34;data&#34;)

        for source_link in spec.source_links:
            sl = SourceLink()
            sl.title = self._get_string_property(source_link.title, &#34;sourcelink.title&#34;, None)
            sl.url = self._get_string_property(source_link.url, &#34;sourcelink.url&#34;, None)
            event.context.source_links.append(sl)
        event.tags = self._get_list_property(spec.tags, &#34;tags&#34;, [])
        source = self._get_string_property(spec.source, &#34;source&#34;, &#34;ETL&#34;)
        event.context.source = source
        event.source = source
        event.msg_title = self._get_string_property(spec.msg_title, &#34;msg_title&#34;, None)
        if event.msg_title is None:
            raise Exception(f&#34;Template {template.name} event msg title is required.&#34;)
        event.msg_text = self._get_string_property(spec.msg_text, &#34;msg_text&#34;)
        self.ctx.factory.add_event(event)
        return event</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.EventTemplateInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, item: Dict[str, Any]) ‑> <a title="stackstate_etl.model.stackstate.Event" href="../model/stackstate.html#stackstate_etl.model.stackstate.Event">Event</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, item: Dict[str, Any]) -&gt; Event:
    template: EventTemplate = self.template
    self.ctx.item = item
    self.ctx.event = event = Event()
    self._update_asteval_symtable()
    spec: EventTemplateSpec = template.spec

    event.event_type = self._get_string_property(spec.event_type, &#34;event_type&#34;, None)
    if event.event_type is None:
        raise Exception(f&#34;Template {template.name} event type is required.&#34;)

    category = self._get_string_property(spec.category, &#34;category&#34;, &#34;&#34;)
    if category not in EVENT_CATEGORY_CHOICES:
        raise Exception(
            f&#34;Template {template.name} event category &#39;{category}&#39; not allowed. &#34;
            f&#34;Valid values {EVENT_CATEGORY_CHOICES}.&#34;
        )

    event.context.category = category
    event.context.element_identifiers = self._get_list_property(spec.element_identifiers, &#34;element_identifiers&#34;, [])
    event.context.data = self._get_dict_property(spec.data, &#34;data&#34;)

    for source_link in spec.source_links:
        sl = SourceLink()
        sl.title = self._get_string_property(source_link.title, &#34;sourcelink.title&#34;, None)
        sl.url = self._get_string_property(source_link.url, &#34;sourcelink.url&#34;, None)
        event.context.source_links.append(sl)
    event.tags = self._get_list_property(spec.tags, &#34;tags&#34;, [])
    source = self._get_string_property(spec.source, &#34;source&#34;, &#34;ETL&#34;)
    event.context.source = source
    event.source = source
    event.msg_title = self._get_string_property(spec.msg_title, &#34;msg_title&#34;, None)
    if event.msg_title is None:
        raise Exception(f&#34;Template {template.name} event msg title is required.&#34;)
    event.msg_text = self._get_string_property(spec.msg_text, &#34;msg_text&#34;)
    self.ctx.factory.add_event(event)
    return event</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.HeathTemplateInterpreter"><code class="flex name class">
<span>class <span class="ident">HeathTemplateInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>, template: <a title="stackstate_etl.model.etl.HealthTemplate" href="../model/etl.html#stackstate_etl.model.etl.HealthTemplate">HealthTemplate</a>, domain: str, layer: str, environment: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeathTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: HealthTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; HealthCheckState:
        template: HealthTemplate = self.template
        self.ctx.item = item
        self.ctx.health = health = HealthCheckState()
        self._update_asteval_symtable()
        spec: HealthTemplateSpec = template.spec

        health.check_id = self._get_string_property(spec.check_id, &#34;check_id&#34;, None)
        if health.check_id is None:
            raise Exception(f&#34;Template {template.name} health check id required.&#34;)

        health.check_name = self._get_string_property(spec.check_name, &#34;check_name&#34;, None)
        if health.check_name is None:
            raise Exception(f&#34;Template {template.name} health check name required.&#34;)

        health.topo_identifier = self._get_string_property(spec.topo_identifier, &#34;topo_identifier&#34;, None)
        if health.topo_identifier is None:
            raise Exception(f&#34;Template {template.name} health topo_identifier required.&#34;)

        health.message = self._get_string_property(spec.message, &#34;message&#34;, &#34;&#34;)

        health_status = self._get_string_property(spec.health, &#34;health&#34;, &#34;&#34;)
        if health_status not in HEALTH_STATE_CHOICES:
            raise Exception(
                f&#34;Template {template.name} health &#39;{health_status}&#39; not allowed. &#34;
                f&#34;Valid values {HEALTH_STATE_CHOICES}.&#34;
            )

        health.health = health_status
        self.ctx.factory.add_health(health)
        return health</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.HeathTemplateInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, item: Dict[str, Any]) ‑> <a title="stackstate_etl.model.stackstate.HealthCheckState" href="../model/stackstate.html#stackstate_etl.model.stackstate.HealthCheckState">HealthCheckState</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, item: Dict[str, Any]) -&gt; HealthCheckState:
    template: HealthTemplate = self.template
    self.ctx.item = item
    self.ctx.health = health = HealthCheckState()
    self._update_asteval_symtable()
    spec: HealthTemplateSpec = template.spec

    health.check_id = self._get_string_property(spec.check_id, &#34;check_id&#34;, None)
    if health.check_id is None:
        raise Exception(f&#34;Template {template.name} health check id required.&#34;)

    health.check_name = self._get_string_property(spec.check_name, &#34;check_name&#34;, None)
    if health.check_name is None:
        raise Exception(f&#34;Template {template.name} health check name required.&#34;)

    health.topo_identifier = self._get_string_property(spec.topo_identifier, &#34;topo_identifier&#34;, None)
    if health.topo_identifier is None:
        raise Exception(f&#34;Template {template.name} health topo_identifier required.&#34;)

    health.message = self._get_string_property(spec.message, &#34;message&#34;, &#34;&#34;)

    health_status = self._get_string_property(spec.health, &#34;health&#34;, &#34;&#34;)
    if health_status not in HEALTH_STATE_CHOICES:
        raise Exception(
            f&#34;Template {template.name} health &#39;{health_status}&#39; not allowed. &#34;
            f&#34;Valid values {HEALTH_STATE_CHOICES}.&#34;
        )

    health.health = health_status
    self.ctx.factory.add_health(health)
    return health</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.MetricTemplateInterpreter"><code class="flex name class">
<span>class <span class="ident">MetricTemplateInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>, template: <a title="stackstate_etl.model.etl.MetricTemplate" href="../model/etl.html#stackstate_etl.model.etl.MetricTemplate">MetricTemplate</a>, domain: str, layer: str, environment: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetricTemplateInterpreter(BaseTemplateInterpreter):
    def __init__(self, ctx: TopologyContext, template: MetricTemplate, domain: str, layer: str, environment: str):
        BaseTemplateInterpreter.__init__(self, ctx, template, domain, layer, environment)

    def interpret(self, item: Dict[str, Any]) -&gt; Optional[Metric]:
        template: MetricTemplate = self.template
        self.ctx.item = item

        if template.spec and template.code:
            raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
        if template.spec:
            return self._interpret_spec(template.spec, template)
        elif template.code:
            return self._interpret_code(template.code)
        else:
            raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)

    def _interpret_spec(self, spec: MetricTemplateSpec, template: MetricTemplate):
        self.ctx.metric = metric = Metric()
        self._update_asteval_symtable()
        metric.name = self._get_string_property(spec.name, &#34;name&#34;, None)
        if metric.name is None:
            raise Exception(f&#34;Template {template.name} metric name is required.&#34;)
        metric.target_uid = self._get_string_property(spec.target_uid, &#34;target_uid&#34;, None)
        metric_type = self._get_string_property(spec.metric_type, &#34;metric_type&#34;, &#34;gauge&#34;)
        if metric_type not in METRIC_TYPE_CHOICES:
            raise Exception(
                f&#34;Template {template.name} metric type &#39;{metric_type}&#39; not allowed. &#34;
                f&#34;Valid values {METRIC_TYPE_CHOICES}.&#34;
            )
        metric.metric_type = metric_type
        metric.value = self._get_float_property(spec.value, &#34;value&#34;)
        metric.tags = self._get_list_property(spec.tags, &#34;tags&#34;, [])
        self.ctx.factory.add_metric(metric)

    def _interpret_code(self, code: str):
        self._update_asteval_symtable()
        self._run_code(code, &#34;code&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></li>
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.MetricTemplateInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, item: Dict[str, Any]) ‑> Optional[<a title="stackstate_etl.model.stackstate.Metric" href="../model/stackstate.html#stackstate_etl.model.stackstate.Metric">Metric</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, item: Dict[str, Any]) -&gt; Optional[Metric]:
    template: MetricTemplate = self.template
    self.ctx.item = item

    if template.spec and template.code:
        raise Exception(f&#34;Template {template.name} cannot have both spec and code properties.&#34;)
    if template.spec:
        return self._interpret_spec(template.spec, template)
    elif template.code:
        return self._interpret_code(template.code)
    else:
        raise Exception(f&#34;Template {template.name} must have either spec and code properties defined.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.ProcessorInterpreter"><code class="flex name class">
<span>class <span class="ident">ProcessorInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessorInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, processor: ProcessorSpec):
        self.source_name = f&#34;processor &#39;{processor.name}&#39;&#34;
        self._update_asteval_symtable()
        self._run_code(processor.code, &#34;code&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.ProcessorInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, processor: <a title="stackstate_etl.model.etl.ProcessorSpec" href="../model/etl.html#stackstate_etl.model.etl.ProcessorSpec">ProcessorSpec</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, processor: ProcessorSpec):
    self.source_name = f&#34;processor &#39;{processor.name}&#39;&#34;
    self._update_asteval_symtable()
    self._run_code(processor.code, &#34;code&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.QueryInterpreter"><code class="flex name class">
<span>class <span class="ident">QueryInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, query: Query) -&gt; List[Dict[str, Any]]:
        self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
        self._update_asteval_symtable()
        items = self._run_code(query.query, &#34;query&#34;)
        if items is None:
            items = []
        if not isinstance(items, list):
            items = [items]
        return items</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.QueryInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, query: <a title="stackstate_etl.model.etl.Query" href="../model/etl.html#stackstate_etl.model.etl.Query">Query</a>) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, query: Query) -&gt; List[Dict[str, Any]]:
    self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
    self._update_asteval_symtable()
    items = self._run_code(query.query, &#34;query&#34;)
    if items is None:
        items = []
    if not isinstance(items, list):
        items = [items]
    return items</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.QueryProcessorInterpreter"><code class="flex name class">
<span>class <span class="ident">QueryProcessorInterpreter</span></span>
<span>(</span><span>ctx: <a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryProcessorInterpreter(BaseInterpreter):
    def __init__(self, ctx: TopologyContext):
        BaseInterpreter.__init__(self, ctx)

    def interpret(self, query: Query):
        self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
        self._update_asteval_symtable()
        self._run_code(query.processor, &#34;processor&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.QueryProcessorInterpreter.interpret"><code class="name flex">
<span>def <span class="ident">interpret</span></span>(<span>self, query: <a title="stackstate_etl.model.etl.Query" href="../model/etl.html#stackstate_etl.model.etl.Query">Query</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpret(self, query: Query):
    self.source_name = f&#34;query &#39;{query.name}&#39;&#34;
    self._update_asteval_symtable()
    self._run_code(query.processor, &#34;processor&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext"><code class="flex name class">
<span>class <span class="ident">TopologyContext</span></span>
<span>(</span><span>*, factory: <a title="stackstate_etl.model.factory.TopologyFactory" href="../model/factory.html#stackstate_etl.model.factory.TopologyFactory">TopologyFactory</a>, item: Dict[str, Any] = None, datasources: Dict[str, Any] = {}, component: <a title="stackstate_etl.model.stackstate.Component" href="../model/stackstate.html#stackstate_etl.model.stackstate.Component">Component</a> = None, event: <a title="stackstate_etl.model.stackstate.Event" href="../model/stackstate.html#stackstate_etl.model.stackstate.Event">Event</a> = None, metric: <a title="stackstate_etl.model.stackstate.Metric" href="../model/stackstate.html#stackstate_etl.model.stackstate.Metric">Metric</a> = None, health: <a title="stackstate_etl.model.stackstate.HealthCheckState" href="../model/stackstate.html#stackstate_etl.model.stackstate.HealthCheckState">HealthCheckState</a> = None, session: Dict[str, Any] = {}, global_session: Dict[str, Any] = {})</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class TopologyContext.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TopologyContext:
    factory: TopologyFactory = attr.ib()
    item: Dict[str, Any] = attr.ib(default=None)
    datasources: Dict[str, Any] = attr.ib(default={})
    component: Component = attr.ib(default=None)
    event: Event = attr.ib(default=None)
    metric: Metric = attr.ib(default=None)
    health: HealthCheckState = attr.ib(default=None)
    session: Dict[str, Any] = attr.ib(default={})
    global_session: Dict[str, Any] = attr.ib(default={})

    def jpath(self, path) -&gt; Any:
        return self.factory.jpath(path, self.item)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.component"><code class="name">var <span class="ident">component</span> : <a title="stackstate_etl.model.stackstate.Component" href="../model/stackstate.html#stackstate_etl.model.stackstate.Component">Component</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.datasources"><code class="name">var <span class="ident">datasources</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.event"><code class="name">var <span class="ident">event</span> : <a title="stackstate_etl.model.stackstate.Event" href="../model/stackstate.html#stackstate_etl.model.stackstate.Event">Event</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.factory"><code class="name">var <span class="ident">factory</span> : <a title="stackstate_etl.model.factory.TopologyFactory" href="../model/factory.html#stackstate_etl.model.factory.TopologyFactory">TopologyFactory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.global_session"><code class="name">var <span class="ident">global_session</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.health"><code class="name">var <span class="ident">health</span> : <a title="stackstate_etl.model.stackstate.HealthCheckState" href="../model/stackstate.html#stackstate_etl.model.stackstate.HealthCheckState">HealthCheckState</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.item"><code class="name">var <span class="ident">item</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.metric"><code class="name">var <span class="ident">metric</span> : <a title="stackstate_etl.model.stackstate.Metric" href="../model/stackstate.html#stackstate_etl.model.stackstate.Metric">Metric</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.session"><code class="name">var <span class="ident">session</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stackstate_etl.etl.interpreter.TopologyContext.jpath"><code class="name flex">
<span>def <span class="ident">jpath</span></span>(<span>self, path) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jpath(self, path) -&gt; Any:
    return self.factory.jpath(path, self.item)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stackstate_etl.etl" href="index.html">stackstate_etl.etl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.BaseInterpreter" href="#stackstate_etl.etl.interpreter.BaseInterpreter">BaseInterpreter</a></code></h4>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter">BaseTemplateInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.BaseTemplateInterpreter.active" href="#stackstate_etl.etl.interpreter.BaseTemplateInterpreter.active">active</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.ComponentTemplateInterpreter" href="#stackstate_etl.etl.interpreter.ComponentTemplateInterpreter">ComponentTemplateInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.ComponentTemplateInterpreter.interpret" href="#stackstate_etl.etl.interpreter.ComponentTemplateInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.DataSourceInterpreter" href="#stackstate_etl.etl.interpreter.DataSourceInterpreter">DataSourceInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.DataSourceInterpreter.interpret" href="#stackstate_etl.etl.interpreter.DataSourceInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.EventTemplateInterpreter" href="#stackstate_etl.etl.interpreter.EventTemplateInterpreter">EventTemplateInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.EventTemplateInterpreter.interpret" href="#stackstate_etl.etl.interpreter.EventTemplateInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.HeathTemplateInterpreter" href="#stackstate_etl.etl.interpreter.HeathTemplateInterpreter">HeathTemplateInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.HeathTemplateInterpreter.interpret" href="#stackstate_etl.etl.interpreter.HeathTemplateInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.MetricTemplateInterpreter" href="#stackstate_etl.etl.interpreter.MetricTemplateInterpreter">MetricTemplateInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.MetricTemplateInterpreter.interpret" href="#stackstate_etl.etl.interpreter.MetricTemplateInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.ProcessorInterpreter" href="#stackstate_etl.etl.interpreter.ProcessorInterpreter">ProcessorInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.ProcessorInterpreter.interpret" href="#stackstate_etl.etl.interpreter.ProcessorInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.QueryInterpreter" href="#stackstate_etl.etl.interpreter.QueryInterpreter">QueryInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.QueryInterpreter.interpret" href="#stackstate_etl.etl.interpreter.QueryInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.QueryProcessorInterpreter" href="#stackstate_etl.etl.interpreter.QueryProcessorInterpreter">QueryProcessorInterpreter</a></code></h4>
<ul class="">
<li><code><a title="stackstate_etl.etl.interpreter.QueryProcessorInterpreter.interpret" href="#stackstate_etl.etl.interpreter.QueryProcessorInterpreter.interpret">interpret</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="stackstate_etl.etl.interpreter.TopologyContext" href="#stackstate_etl.etl.interpreter.TopologyContext">TopologyContext</a></code></h4>
<ul class="two-column">
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.component" href="#stackstate_etl.etl.interpreter.TopologyContext.component">component</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.datasources" href="#stackstate_etl.etl.interpreter.TopologyContext.datasources">datasources</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.event" href="#stackstate_etl.etl.interpreter.TopologyContext.event">event</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.factory" href="#stackstate_etl.etl.interpreter.TopologyContext.factory">factory</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.global_session" href="#stackstate_etl.etl.interpreter.TopologyContext.global_session">global_session</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.health" href="#stackstate_etl.etl.interpreter.TopologyContext.health">health</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.item" href="#stackstate_etl.etl.interpreter.TopologyContext.item">item</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.jpath" href="#stackstate_etl.etl.interpreter.TopologyContext.jpath">jpath</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.metric" href="#stackstate_etl.etl.interpreter.TopologyContext.metric">metric</a></code></li>
<li><code><a title="stackstate_etl.etl.interpreter.TopologyContext.session" href="#stackstate_etl.etl.interpreter.TopologyContext.session">session</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>